syntax = "proto2"; // Used so `required` is available.

package idp;

// import public "idp_common.proto";

//
// Helper types
//

message ContentType {
    required bytes value = 1;
}

message Did {
    required string value = 1;
}

message Nonce {
    required bytes value = 1;
}

// message Seal {
//     oneof value {
//         Sha256Sum Sha256Sum = 1;
//         // TODO: Crypto signature types
//     }
// }

message Seal {
    // TEMP HACK -- it should support more seal types
    required Sha256Sum sha256sum = 1;
}

message Sha256Sum {
    required bytes value = 1;
}

message UnixSeconds {
    required int64 value = 1;
}

//
// Plum-specific types
//

message PlumHeadSeal {
    required Seal value = 1;
}

message PlumRelationsSeal {
    required Seal value = 1;
}

message PlumBodySeal {
    required Seal value = 1;
}

message PlumHead {
    // PlumBodySeal uniquely identifies a PlumBody (for authentication and lookup into the DB/store of PlumBody-s)
    required PlumBodySeal body_seal = 1;
    // Content type for the Plum body.
    required ContentType body_content_type = 2;
    // Number of bytes in the Plum body itself.
    required uint64 body_length = 3;
    // Optional nonce for preventing dictionary attacks.
    optional Nonce head_nonce_o = 4;
    // Optional owner DID.
    optional Did owner_did_o = 5;
    // Optional Plum creation timestamp.
    optional UnixSeconds created_at_o = 6;
    // Optional, unstructured metadata.
    optional bytes metadata_o = 7;
    // Optional PlumRelationsSeal uniquely identifies a PlumRelations (for authentication of PlumRelations-es)
    optional PlumRelationsSeal relations_seal_o = 8;
}

// This defines what relations are possible from one Plum to another.
enum Relation {
    CONTENT_DEPENDENCY = 0;
    METADATA_DEPENDENCY = 1;
}

// A set of Relations, encoded as bitflags.
message RelationFlagsRaw {
    required uint32 value = 1;
}

message PlumRelationFlagsMapping {
    required PlumHeadSeal target_head_seal = 1;
    required RelationFlagsRaw relation_flags_raw = 2;
}

// This encapsulates the Relations from a given Plum to all others, and is derived from its PlumBody.
// The reason this is separate is because there are situations where the PlumBody won't be present
// but that Plum's Relations are needed.
message PlumRelations {
    // Optional nonce can be used to prevent dictionary attacks.
    optional Nonce relations_nonce_o = 1;
    // Content of the relations itself.  This consists of entries to add to the relations DB table.
    repeated PlumRelationFlagsMapping relation_flags_mappings = 2;
}

message PlumBody {
    // Optional nonce can be used to prevent dictionary attacks.
    optional Nonce body_nonce_o = 1;
    // Content of the plum itself.  The content type of the bytes is given in the PlumHead.
    required bytes body_content = 2;
}

// This represents a single data entry; it's a head (metadata), relations, and a body (file content).
// Yes, a stupid name, and I hate cute names in software, but it is distinct, and it's a noun.
message Plum {
    required PlumHead head = 1;
    optional PlumRelations relations_o = 2;
    required PlumBody body = 3;
}

//
// Requests and Responses
//

//
// Push
//

message PushHeadRequest {
    required PlumHead head = 1;
}

message PushBodyRequest {
    required PlumBody body = 1;
}

message PushHeadAndBodyRequest {
    required Plum plum = 1;
}

message PushRequest {
    oneof value {
        PushHeadRequest push_head_request = 1;
        PushBodyRequest push_body_request = 2;
        PushHeadAndBodyRequest push_head_and_body_request = 3;
    }
}

message PushHeadResponse {
    required PlumHeadSeal head_seal = 1;
}

message PushBodyResponse {
    required PlumBodySeal body_seal = 1;
}

message PushHeadAndBodyResponse {
    required PlumHeadSeal head_seal = 1;
    required PlumBodySeal body_seal = 2;
}

message PushResponse {
    oneof value {
        PushHeadResponse push_head_response = 1;
        PushBodyResponse push_body_response = 2;
        PushHeadAndBodyResponse push_head_and_body_response = 3;
    }
}

//
// Pull
//

message PullHeadRequest {
    required PlumHeadSeal head_seal = 1;
}

message PullBodyRequest {
    required PlumBodySeal body_seal = 1;
}

message PullHeadAndBodyRequest {
    required PlumHeadSeal head_seal = 1;
    required PlumBodySeal body_seal = 2;
}

message PullRequest {
    oneof value {
        PullHeadRequest pull_head_request = 1;
        PullBodyRequest pull_body_request = 2;
        PullHeadAndBodyRequest pull_head_and_body_request = 3;
    }
}

message PullHeadResponse {
    required PlumHead head = 1;
}

message PullBodyResponse {
    required PlumBody body = 1;
}

message PullHeadAndBodyResponse {
    required Plum plum = 1;
}

message PullResponse {
    oneof value {
        PullHeadResponse pull_head_response = 1;
        PullBodyResponse pull_body_response = 2;
        PullHeadAndBodyResponse pull_head_and_body_response = 3;
    }
}

//
// Del
//

message DelHeadRequest {
    required PlumHeadSeal head_seal = 1;
}

message DelBodyRequest {
    required PlumBodySeal body_seal = 1;
}

message DelHeadAndBodyRequest {
    required PlumHeadSeal head_seal = 1;
    required PlumBodySeal body_seal = 2;
}

// TODO: Could implement bidirectional streaming of Del.
message DelRequest {
    oneof value {
        DelHeadRequest del_head_request = 1;
        DelBodyRequest del_body_request = 2;
        DelHeadAndBodyRequest del_head_and_body_request = 3;
    }
}

message DelHeadResponse {
    // Nothing needed
}

message DelBodyResponse {
    // Nothing needed
}

message DelHeadAndBodyResponse {
    // Nothing needed
}

message DelResponse {
    oneof value {
        DelHeadResponse del_head_response = 1;
        DelBodyResponse del_body_response = 2;
        DelHeadAndBodyResponse del_head_and_body_response = 3;
    }
}

//
// Service definition
//

service IndoorDataPlumbing {
    // TODO: Figure out what to pass so that the server could say "i already have that" and then
    // not transfer the bulk of the data.
    // TODO: Could implement bidirectional streaming of Push.
    rpc Push (PushRequest) returns (PushResponse) {}
    // TODO: Could implement bidirectional streaming of Pull.
    rpc Pull (PullRequest) returns (PullResponse) {}
    rpc Del (DelRequest) returns (DelResponse) {}
}
