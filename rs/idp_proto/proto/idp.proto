syntax = "proto2"; // Used so `required` is available.

package idp;

// import public "idp_common.proto";

//
// Helper types
//

message ContentType {
    required bytes value = 1;
}

message Id {
    required string value = 1;
}

message Nonce {
    required bytes value = 1;
}

// message Seal {
//     oneof value {
//         Sha256Sum Sha256Sum = 1;
//         // TODO: Crypto signature types
//     }
// }

message Seal {
    // TEMP HACK -- it should support more seal types
    required Sha256Sum sha256sum = 1;
}

message Sha256Sum {
    required bytes value = 1;
}

// Storing nanoseconds in an int64 gives 292.27 years range around the Unix epoch, 1970-01-01 UTC.
message UnixNanoseconds {
    required int64 value = 1;
}

//
// Plum-specific types
//

message PlumHeadSeal {
    required Seal value = 1;
}

message PlumRelationsSeal {
    required Seal value = 1;
}

message PlumBodySeal {
    required Seal value = 1;
}

message PlumHead {
    // Optional nonce for preventing dictionary attacks.  This would be left as None e.g. in storing "a plain file"
    // or otherwise for data that has no need for the protection the nonce provides.
    optional Nonce plum_head_nonce_o = 1;
    // Optional PlumRelationsSeal uniquely identifies a PlumRelations (for authentication of PlumRelations-es).
    // This would be left as None e.g. in storing "a plain file", or otherwise for data that doesn't have any
    // formal plum_relations.
    optional PlumRelationsSeal plum_relations_seal_o = 2;
    // PlumBodySeal uniquely identifies a PlumBody (for authentication and lookup into the DB/store of PlumBody-s)
    required PlumBodySeal plum_body_seal = 3;
    // Optional owner DID.  This would be left as None e.g. in storing "a plain file", or otherwise for data that
    // has no need for a formal owner.
    optional Id owner_id_o = 4;
    // Optional Plum creation timestamp.
    optional UnixNanoseconds created_at_o = 5;
    // Optional, unstructured metadata.  This would be left as None e.g. in storing "a plain file", or otherwise
    // for data that has no need for metadata.
    optional bytes metadata_o = 6;
}

// This defines what plum_relations are possible from one Plum to another.
enum PlumRelation {
    CONTENT_DEPENDENCY = 0;
    METADATA_DEPENDENCY = 1;
}

// A set of Relations, encoded as bitflags.
message PlumRelationFlagsRaw {
    required uint32 value = 1;
}

message PlumRelationFlagsMapping {
    required PlumHeadSeal target_plum_head_seal = 1;
    required PlumRelationFlagsRaw plum_relation_flags_raw = 2;
}

// This encapsulates the Relations from a given Plum to all others, and is derived from its PlumBody.
// The reason this is separate is because there are situations where the PlumBody won't be present
// but that Plum's Relations are needed.
message PlumRelations {
    // Optional nonce can be used to prevent dictionary attacks.
    optional Nonce plum_relations_nonce_o = 1;
    // PlumBodySeal of the Plum that these relations come from.
    required PlumBodySeal source_plum_body_seal = 2;
    // Content of the plum_relations itself.  This consists of entries to add to the plum_relations DB table.
    repeated PlumRelationFlagsMapping plum_relation_flags_mapping_v = 3;
}

message PlumBody {
    // Optional nonce can be used to prevent dictionary attacks.
    optional Nonce plum_body_nonce_o = 1;
    // Number of bytes in the Plum body itself.
    required uint64 plum_body_content_length = 2;
    // Content type for the Plum body.
    required ContentType plum_body_content_type = 3;
    // Content of the plum itself.  The content type of the bytes is given in the PlumHead.
    required bytes plum_body_content = 4;
}

// This represents a single data entry; it's a head (metadata), plum_relations, and a body (file content).
// Yes, a stupid name, and I hate cute names in software, but it is distinct, and it's a noun.
// And at least it doesn't end with "ly".
message Plum {
    required PlumHead plum_head = 1;
    optional PlumRelations plum_relations_o = 2;
    required PlumBody plum_body = 3;
}

//
// Requests and Responses
//

message Acknowledgement {}

//
// Push -- Push means to push a given Plum and its full tree of dependencies to the server.
// TODO: Add a PushHeadRequest, which does the same as a full Push, but only pushes heads.
//

// These stream from client to server, starting with the PlumHeadSeal, and the server streams
// responses to say which PlumHeadSeals it already has Plums for (and therefore the client
// doesn't have to push the Plum or recurse on its dependencies).  Thus there won't be much
// wasted bandwidth.
// TODO: break it apart into sending plum head, plum plum_relations, plum body.  This requires
// the server responding with which ones are needed for a given PlumHeadSeal.
message PushRequest {
    oneof value {
        PlumHeadSeal should_i_send_this_plum = 1;
        Plum here_have_a_plum = 2;
    }
}

// TODO: Potentially could respond with a boolean, as long as the client can reliably
// pair the response with the request in the bidirectional streaming.
message PushResponse {
    oneof value {
        // Response to here_have_a_plum; carries no information.  TODO: This isn't actually necessary,
        // as long as the request/response streaming doesn't need to be 1-to-1
        Acknowledgement ok = 1;
        // Positive response to should_i_send_this_plum.  TODO: Maybe rename to i_want_this_plum.
        PlumHeadSeal send_this_plum = 2;
        // Negative response to should_i_send_this_plum.  TODO: This isn't actually necessary,
        // as long as the request/response streaming doesn't need to be 1-to-1
        PlumHeadSeal dont_send_this_plum = 3;
    }
}

message PlumHeadAndRelations {
    required PlumHead plum_head = 1;
    required PlumRelations plum_relations = 2;
}

message PlumHeadSealAndRelations {
    required PlumHeadSeal plum_head_seal = 1;
    required PlumRelations plum_relations = 2;
}

// These stream from client to server, starting with the PlumHeadSeal, and the server streams
// responses to say which PlumHeadSeals it already has Plums for (and therefore the client
// doesn't have to push the Plum or recurse on its dependencies).  Thus there won't be much
// wasted bandwidth.
// TODO: break it apart into sending plum head, plum plum_relations, plum body.  This requires
// the server responding with which ones are needed for a given PlumHeadSeal.
message PullRequest {
    oneof value {
        // TEMP HACK -- simple for now.
        PlumHeadSeal i_want_this_plum = 1;

        // PlumHeadSeal i_want_this_plum_head = 1;
        // PlumHeadSeal i_want_this_plum_relations = 2;
        // PlumHeadSeal i_want_this_plum_head_and_relations = 3;
        // PlumBodySeal i_want_this_plum_body = 4;
        // PlumHeadSeal i_want_this_plum = 5;
    }

    // required PlumHeadSeal i_want_this_plum = 1;
    // oneof value {
    //     PlumHeadSeal i_want_this_plum = 1;
    //     // TODO: This isn't actually necessary, as long as the request/response streaming doesn't
    //     // need to be 1-to-1
    //     // PlumHeadSeal i_dont_want_this_plum = 2;
    // }
}

message PullResponse {
    oneof value {
        // TEMP HACK -- simple for now.
        Plum plum = 1;
        PlumHeadSeal i_dont_have_this_plum = 2;

        // PlumHead plum_head = 1;
        // // In order to make sense of PlumRelations, the PlumHeadSeal it corresponds to is necessary.
        // PlumHeadSealAndRelations plum_head_seal_and_relations = 2;
        // // It's common to want both the PlumHead and PlumRelations at the same time.
        // PlumHeadAndRelations plum_head_and_relations = 3;
        // PlumBody plum_body = 4;
        // Plum plum = 5;

        // PlumHeadSeal i_dont_have_this_plum_head = 6;
        // PlumHeadSeal i_dont_have_this_plum_relations = 7;
        // PlumBodySeal i_dont_have_this_plum_body = 8;
    }
}

// message PlumHeadSealVec {
//     required PlumHeadSeal plum_head_seal_v = 1;
// }

// message PlumVec {
//     required Plum plum_v = 1;
// }

// //
// // Pull
// //

// message PullHeadRequest {
//     required PlumHeadSeal head_seal = 1;
// }

// message PullBodyRequest {
//     required PlumBodySeal body_seal = 1;
// }

// message PullHeadAndBodyRequest {
//     required PlumHeadSeal head_seal = 1;
//     required PlumBodySeal body_seal = 2;
// }

// message PullRequest {
//     oneof value {
//         PullHeadRequest pull_head_request = 1;
//         PullBodyRequest pull_body_request = 2;
//         PullHeadAndBodyRequest pull_head_and_body_request = 3;
//     }
// }

// message PullHeadResponse {
//     required PlumHead head = 1;
// }

// message PullBodyResponse {
//     required PlumBody body = 1;
// }

// message PullHeadAndBodyResponse {
//     required Plum plum = 1;
// }

// message PullResponse {
//     oneof value {
//         PullHeadResponse pull_head_response = 1;
//         PullBodyResponse pull_body_response = 2;
//         PullHeadAndBodyResponse pull_head_and_body_response = 3;
//     }
// }

// //
// // Del
// //

// message DelHeadRequest {
//     required PlumHeadSeal head_seal = 1;
// }

// message DelBodyRequest {
//     required PlumBodySeal body_seal = 1;
// }

// message DelHeadAndBodyRequest {
//     required PlumHeadSeal head_seal = 1;
//     required PlumBodySeal body_seal = 2;
// }

// // TODO: Could implement bidirectional streaming of Del.
// message DelRequest {
//     oneof value {
//         DelHeadRequest del_head_request = 1;
//         DelBodyRequest del_body_request = 2;
//         DelHeadAndBodyRequest del_head_and_body_request = 3;
//     }
// }

// message DelHeadResponse {
//     // Nothing needed
// }

// message DelBodyResponse {
//     // Nothing needed
// }

// message DelHeadAndBodyResponse {
//     // Nothing needed
// }

// message DelResponse {
//     oneof value {
//         DelHeadResponse del_head_response = 1;
//         DelBodyResponse del_body_response = 2;
//         DelHeadAndBodyResponse del_head_and_body_response = 3;
//     }
// }

message Path {
    required string value = 1;
}

message PathState {
    required Path path = 1;
    required PlumHeadSeal current_state_plum_head_seal = 2;
    // TODO: Consider including the "updated at" and "deleted at" timestamps; also ownership/permissions when the time comes
}

// The requester should have already pushed the BranchNode Plum referred to in this request.
message BranchCreateRequest {
    required PathState branch_path_state = 1;
}

message BranchCreateResponse { }

message BranchDeleteRequest {
    required Path branch_path = 1;
}

message BranchDeleteResponse { }

message BranchGetHeadRequest {
    required Path branch_path = 1;
}

message BranchGetHeadResponse {
    required PlumHeadSeal branch_head_plum_head_seal = 1;
}

message BranchSetHeadRequest {
    required Path branch_path = 1;
    oneof value {
        PlumHeadSeal branch_fast_forward_to_plum_head_seal = 2;
        PlumHeadSeal branch_rewind_to_plum_head_seal = 3;
        PlumHeadSeal branch_force_reset_to_plum_head_seal = 4;
    }
}

message BranchSetHeadResponse { }

//
// Service definition
//

service IndoorDataPlumbing {
    rpc Push (stream PushRequest) returns (stream PushResponse) {}
    rpc Pull (PullRequest) returns (stream PullResponse) {}

    // // TODO: Could implement bidirectional streaming of Pull.
    // rpc Pull (PullRequest) returns (PullResponse) {}
    // rpc Del (DelRequest) returns (DelResponse) {}

    // TODO: Consider moving these into a separate GRPC service
    rpc BranchCreate (BranchCreateRequest) returns (BranchCreateResponse) {}
    rpc BranchDelete (BranchDeleteRequest) returns (BranchDeleteResponse) {}
    rpc BranchGetHead (BranchGetHeadRequest) returns (BranchGetHeadResponse) {}
    rpc BranchSetHead (BranchSetHeadRequest) returns (BranchSetHeadResponse) {}
}
